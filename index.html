<!DOCTYPE html>

<html lang="en-US">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Rust for Non-Systems Programmers</title>
<link href="dist/reset.css" rel="stylesheet"/>
<link href="dist/reveal.css" rel="stylesheet"/>
<link href="dist/theme/rustconf.css" id="theme" rel="stylesheet"/>
<link href="plugin/highlight/rustconf.css" id="highlight-theme" rel="stylesheet"/>
<script crossorigin="anonymous" src="https://kit.fontawesome.com/9144026ed3.js"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section><div class="slide-wrapper">
<h1>Rust <div class="small">for</div> Non-Systems Programmers</h1>
<p><span class="author">Rebecca Turner</span></p>
<p><i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo/">becca.ooo</a></p>
<aside class="notes"><p> Hey folks, my name is Rebecca Turner and I'm going to tell you why you
should be writing non-systems code in Rust.</p>
<div class="next-slide"><p>Next slide: Why this talk?</p></div>

</aside></div></section>
<section class="title-card"><div class="slide-wrapper">
<h2>Why this talk?</h2>
<aside class="notes"><p> I'm a non-systems programmer, and I really like Rust. But if you
looked at the <a href="https://rust-lang.org/">rust-lang.org</a> website before 2019, that might not make
sense to you.</p>
<div class="next-slide"><p>Next slide: Screenshot of <a href="https://rust-lang.org/">rust-lang.org</a> in 2018.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="image-slide"><div class="slide-wrapper">
<img alt='A screenshot of the rust-lang.org website in late 2018. The headline reads "Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety."' src="img/rust-2018-11-30.png"/>
<aside class="notes"><p> Here's the <a href="https://rust-lang.org/">rust-lang.org</a> website at the end of 2018, right before
they rolled out the new site. The headline emphasizes systems programming,
speed, and memory safety — all things I don't directly care about that much.</p>
<div class="next-slide"><p>Next slide: Compare that with the new website.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="image-slide"><div class="slide-wrapper">
<img alt='A screenshot of the rust-lang.org website in mid-2020. The headline reads "A language empowering everyone to build reliable and efficient software." and sections under "Why Rust?" emphasize performance, reliability, and productivity.' src="img/rust-2020-07-19.png"/>
<aside class="notes"><p> And here's the same website today in mid-2020. Now we're "empowering
everyone" to and focusing on reliability and productivity. But a lot of the
documentation has lagged behind and still assumes that new Rust programmers
already know C++ or something similar.</p>
<p>So I want to introduce the rest of us to Rust.</p>
<div class="next-slide"><p>Next slide: What can Rust do for you?</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card" data-state="peach"><div class="slide-wrapper">
<h2>What can Rust <br/> do for you?</h2>
<aside class="notes"><p> Before we get too involved, let's get a quick feel for some of the
things Rust makes strikingly easy.</p>
<div class="next-slide"><p>Next slide: Command-line help messages.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-plain left">rustconf-code 0.1.0
A command-line interface to the openweathermap.org API

USAGE:
    rustconf-code [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --config &lt;config&gt;    Config filename; a JSON file with
                             an `api_key` field
                             [default: openweather_api.json]
</code></pre>
<aside class="notes"><p> Rust can do command-line argument parsing...</p>
<div class="next-slide"><p>Next slide: that's generated from a struct.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/structopt">structopt</a>::StructOpt;

/// A command-line interface to the openweathermap.org API.
#[derive(Debug, StructOpt)]
struct Opt {
    /// Config filename; a JSON file with an `api_key` field.
    #[structopt(
        short, long, parse(from_os_str),
        default_value = "openweather_api.json"
    )]
    config: PathBuf,
}

fn main() {
  Opt::from_args();
}
</code></pre>
<aside class="notes"><p> ...that's generated from a type definition.</p>
<div class="next-slide"><p>Next slide: JSON deserialization example.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ ./target/debug/rustconf-code --config bad-schema.json
Error: Failed to deserialize configuration JSON

Caused by:
    invalid type: map, expected a string at line 2 column 14
</code></pre>
<aside class="notes"><p> Rust can give you great error reports for complex errors...</p>
<div class="next-slide"><p>Next slide: …while automatically deserializing JSON to a custom type.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/serde">serde</a>::Deserialize;
use <a href="https://docs.rs/eyre">eyre</a>::WrapErr;

#[derive(Deserialize, Debug, Clone)]
struct Config {
    api_key: String,
}

fn main() -&gt; eyre::Result&lt;()&gt; {
    let opt = Opt::from_args();
    let config_json = File::open(&amp;opt.config)?;
    let config: OpenWeather = serde_json::from_reader(
        &amp;config_json,
    )
    .wrap_err("Failed to deserialize configuration JSON")?;
}
</code></pre>
<aside class="notes"><p> ...while automatically deserializing a JSON blob to a custom type.</p>
<div class="next-slide"><p>Next slide: Pretty test diffs.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper"><pre class="term">running 1 test
test tests::str_test ... <span style="color: #CC0000">FAILED</span>

failures:
---- tests::str_test stdout ----
thread 'tests::str_test' panicked at
'assertion failed: `(left == right)`

<b>Diff</b> <span style="color: #CC0000">&lt; left</span> / <span style="color: #4E9A06">right &gt;</span> :
<span style="color: #CC0000">&lt;"Hello, RustConf!"</span>
<span style="color: #4E9A06">&gt;"Hello, RustConf</span><span style="background-color:#005F00"><span style="color: #4E9A06"><b> 2020</b></span></span><span style="color: #4E9A06">!"</span>

', src/main.rs:11:9

test result: <span style="color: #CC0000">FAILED</span>. 0 passed; 1 failed; 0 ignored;
0 measured; 0 filtered out
</pre>
<aside class="notes"><p> Rust can output fancy test diffs...</p>
<div class="next-slide"><p>Next slide: <code>pretty_assertions</code> code.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">#[cfg(test)]
mod tests {
    use <a href="https://docs.rs/pretty_assertions">pretty_assertions</a>::assert_eq;

    #[test]
    fn str_test() {
        assert_eq!("Hello, RustConf!", "Hello, RustConf 2020!");
    }
}
</code></pre>
<aside class="notes"><p> ...with a one-line import that integrates with the default test framework.</p>
<div class="next-slide"><p>Next slide: (And more.)</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card" data-state="teal"><div class="slide-wrapper">
<h2>(And a lot more)</h2>
<aside class="notes"><p> Rust can do a lot more, too. But I don't just want to list random Rust
features for 30 minutes.</p>
<div class="next-slide"><p>Next slide: What is this talk?</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card"><div class="slide-wrapper">
<h2>What is this talk?</h2>
<aside class="notes"><p> Before I figured out Rust, I was primarily a Python programmer. I found
— and still find – a lot of Rust documentation aimed more at C++ programmers
than Python programmers. I've never really understood memory management, which
means that I don't feel comfortable writing C++ and I don't understand that
sort of documentation.</p>
<p>I also used to struggle to figure out how Rust would be used for actually
<em>doing</em> the things I wanted to do — writing user-level applications.</p>
<p>So we're going to write a non-trivial Rust program together, and see how we can
solve a lot of common problems in a Rust-y way.</p>
<div class="next-slide"><p>Next slide: What is this talk <em>not</em>?</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card" data-state="purple"><div class="slide-wrapper">
<h2>What is this talk <em>not</em>?</h2>
<aside class="notes"><p> There's a lot of stuff that isn't a high priority to me as a Python
programmer in Rust, that I'm going to pretty much skip entirely.</p>
<p>We're not going to optimize anything, because the totally naive program we're
going to write takes 1/10th of a second to run, which is almost entirely
waiting on some network requests.</p>
<p>We're not going to talk about macros, or a lot of the fancy type system
features Rust has, or pointers. I'm not even going to <em>say</em> the words "heap" or
"stack" or "allocate" — if it wouldn't matter in Python or JavaScript or
Ruby, it's out of scope here.</p>
<div class="next-slide"><p>Next slide: Who is this talk for?</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<h2>Who is this talk for?</h2>

<ul>
<li class="fragment">Programmers comfortable in dynamic languages like Python, JavaScript, Ruby,
etc.</li>
<li class="fragment">Who are tired of some of the problems with those languages:
<ul>
<li class="fragment">Null/undefined errors</li>
<li class="fragment">Runtime type errors</li>
<li class="fragment">Poor documentation</li>
<li class="fragment">Fragmented ecosystem / inconsistent tooling</li>
</ul>
</li>
</ul>
<aside class="notes"><p> In particular, I want to talk to programmers who are already comfortable
in dynamic scripting languages who are beginning to feel some of the downsides
of working in those languages.</p>
<div class="next-slide"><p>Next slide: Why do I like Rust?</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card" data-state="peach"><div class="slide-wrapper">
<h2>Why do I like Rust?</h2>
<aside class="notes"><p> I have ADHD, and it varies from person to person but one area I really
struggle with is <a href="https://en.wikipedia.org/wiki/Working_memory"><em>working memory</em></a>, which is roughly how much
information you can hold in your head at once. And as an engineer, that means
that I can't hold much of the program concept in my mind while I work.</p>
<p>It's really important that I have a powerful compiler, linters, and tests
because otherwise I have no way of knowing that the program's correct — and
I also really need type annotations and autocompletion to remember which
operations are supported on which variables.</p>
<p>Rust <em>really shines</em> in all of these areas. I work <em>with</em> the compiler to
check my work. And it helps me feel a lot more confident that my programs do
what I think they do.</p>
<div class="next-slide"><p>Next slide: Tooling.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<h2>Tooling</h2>

<ul>
<li class="fragment">Documentation: <a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> (API docs) and <a href="https://rust-lang.github.io/mdBook/">mdBook</a> (long-form guides)</li>
<li class="fragment">Language servers: <a href="official">rls</a> and <a href="community">rust-analyzer</a></li>
<li class="fragment">Package manager, build system: <a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">Cargo</a></li>
</ul>
<aside class="notes"><p> Before we get started, I want to point out a few of the tools that
making writing Rust easy and fun.</p>
<ul>
<li>rustdoc compiles <code>///</code> doc comments written in Markdown to webpages —
complete with search, links, and more.</li>
<li>mdBook is used for writing longer-form narrative-style documentation; the
Rust Book and more are written with mdBook and serve as companions to the
rustdoc documentation.</li>
<li>Two very good language servers provide autocompletion, definition-jumping,
quick fixes, and more.</li>
<li>Cargo is a package manager and build system, integrating with the crates.io
package repository.</li>
</ul>
<div class="next-slide"><p>Next slide: A bit more on documentation.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="image-slide"><div class="slide-wrapper">
<h2>Documentation</h2>
<div class="r-stack">
<iframe class="main" data-fragment-index="0" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/"></iframe>
<iframe class="fragment fade-in main" data-fragment-index="0" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/fn.thread_rng.html"></iframe>
<iframe class="fragment fade-in main" data-fragment-index="1" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/rngs/struct.ThreadRng.html"></iframe>
<iframe class="fragment fade-in main" data-fragment-index="2" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/rngs/struct.ThreadRng.html#implementations"></iframe>
<iframe class="fragment fade-in main" data-fragment-index="3" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/trait.RngCore.html"></iframe>
<iframe class="fragment fade-in main" data-fragment-index="4" importance="low" loading="lazy" src="https://docs.rs/rand/0.7.3/rand/trait.RngCore.html#required-methods"></iframe>
</div>
<aside class="notes"><p> Here's the generated documentation for the <a href="https://docs.rs/rand"><code>rand</code></a> crate, which you can
find at <a href="https://docs.rs/rand/">docs.rs/rand</a>.</p>
<ol>
<li>We can see the overview they wrote, and we can search the crate's items —
with keyboard shortcuts!</li>
<li>If we click on the <code>thread_rng</code> function, we get to this definition. Let's
click the return type and check out the documentation for <code>ThreadRng</code>.</li>
<li>If we scroll down a bit, we can see the traits <code>ThreadRng</code> implements. Let's
check out the documentation for <code>RngCore</code>.</li>
<li>We can see a description at first…</li>
<li>And if we scroll down, we can see the required methods and their documentation.</li>
</ol>
<div class="next-slide"><p>Next slide: Hello, world!</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<h2>Getting started</h2>
<pre><code class="language-rust no-line-numbers" data-line-numbers="1-10|1|3-10|4|5-9|5|8" data-noescape="">use <a href="https://docs.rs/std">std</a>::env;

fn main() {
    let user = env::var("USER").unwrap();
    if user == "becca" {
        println!("Hello, Rebecca!");
    } else {
        println!("Hello, {}!", user);
    }
}
</code></pre>
<aside class="notes"><p> Here's a pretty simple rust program, just to show off a bit of syntax.</p>
<ol>
<li>
<p>The <code>use</code> statement imports names from libraries. <code>::</code> is used as a path
separator / namespacing operator.</p>
</li>
<li>
<p>Next, we define a function with the <code>fn</code> keyword; The function named
<code>main</code> is the entry point.</p>
</li>
<li>
<p>We call the <code>var</code> function in the <code>env</code> module, and assign the value it
returns to <code>user</code>; Rust figures out the type for us.</p>
<p><code>env::var</code> returns a <code>Result</code>, so we have to unwrap it, which will crash
if there's an error.</p>
</li>
<li>
<p>Next, we have an <code>if</code> statement, which has braces but no parenthesis.</p>
</li>
<li>
<p>Note that we're also comparing strings with <code>==</code> — rust has operator overloading!</p>
</li>
<li>
<p>Finally, we have this <code>println!</code> macro — the <code>!</code> means it's a macro, and
the string literal there is actually turned into a series of formatting
instructions at compile time so we don't waste time parsing at runtime.</p>
</li>
</ol>
<div class="next-slide"><p>Next slide: <code>cargo build</code>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ cargo build
   Compiling rustconf-code v0.1.0 (~/rustconf/rustconf-code)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
</code></pre>
<aside class="notes"><p> We can run <code>cargo build</code> to compile the program.</p>
<div class="next-slide"><p>Next slide: running the program.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-shell-session">$ ./target/debug/rustconf-code
Hello, Rebecca!
$ USER=nell ./target/debug/rustconf-code
Hello, nell!
</code></pre>
<aside class="notes"><p> And then we can run it, and it does what we expect.</p>
<div class="next-slide"><p>Next slide: …although, we might not really expect an empty variable.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-shell-session no-line-numbers left" data-line-numbers="1-2|3-7">$ env USER= ./target/debug/rustconf-code
Hello, !
$ env USER="$(printf '\xc3\x28')" ./target/debug/rustconf-code
thread 'main' panicked at 'called `Result::unwrap()` on an
`Err` value: NotUnicode("\xC3(")', src/main.rs:4:16
note: run with `RUST_BACKTRACE=1` environment variable to display
a backtrace
</code></pre>
<aside class="notes"><p> ...although, we might not really expect an empty variable.</p>
<p>Also, invalid UTF-8 will crash the whole program.</p>
<div class="next-slide"><p>Next slide: The <code>Result</code> type.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-rust" data-noescape="">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<aside class="notes"><p> <code>Result</code> is an <code>enum</code> — what functional programmers call a sum type.
While a tuple has a value from any number of different types at the same time, a
sum type has a value from <em>one</em> of a number of different types.</p>
<p><code>Result</code> is generic, so for any types <code>T</code> and <code>E</code>, we have a type <code>Result&lt;T, E&gt;</code> which can be <em>either</em> an <code>Ok</code> value of type <code>T</code> or an <code>Err</code> value of type
<code>E</code>; that's pretty much equivalent to a function returning <code>T</code> or throwing an
exception <code>E</code>.</p>
<div class="next-slide"><p>Next slide: gracefully handling errors with <code>match</code>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/std">std</a>::env;

fn main() {
    let user = env::var("USER");
    match user {
        Ok(user) =&gt; {
            if user == "becca" {
                println!("Hello, Rebecca!");
            } else {
                println!("Hello, {}!", user);
            }
        }
        Err(_) =&gt; println!("I couldn't figure out who you are!"),
    }
}
</code></pre>
<aside class="notes"><p> One way we can deal with that error is by matching on it, which is a
little bit like a type-safe <code>isinstance</code> check. Here, we just handle an error
by printing a simple message.</p>
<div class="next-slide"><p>Next slide: showing what happens when we run it.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="center"><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ env USER="$(printf '\xc3\x28')" ./target/debug/rustconf-code
I couldn't figure out who you are!
</code></pre>
<aside class="notes"><p> Now, when we run our program, we print an error message instead of
crashing. We'll talk about some other ways to handle errors as we go, but for the
definitive rundown check out Jane Ludsby's talk <a href="https://rustconf.com/schedule/error-handling-isn-t-all-about-errors">"Error Handling Isn't All
About Errors"</a>.</p>
<p>But this talk is about Rust's value as a practical programming language,
which means doing more than writing "Hello, world!"s. So lets write a program
in Rust and explore some of the ways the language helps us out.</p>
<div class="next-slide"><p>Next slide: receipt printer, weather program overview.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="image-slide"><div class="slide-wrapper">
<img alt='A Star TSP100 Eco futurePRNT 72mm receipt printer, powered on with a printed receipt showing the RustConf homepage reading "Beaming to screens across the globe"' src="img/receipt-printer.jpg"/>
<aside class="notes"><p> I have this receipt printer hooked up to my computer, and it's super fun
to play with — there's no ink, so paper is incredibly cheap, and they're
designed for restaurants and retail, so they're incredibly durable.</p>
<p>I always forget to check the weather in the morning, so I want to write a
program I can set to run before I wake up that tells me the weather, and how
it'll feel compared to the previous day.</p>
<div class="next-slide"><p>Next slide: Minimal API call with OpenWeather.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-python left">import json

import requests

with open("openweather_api.json") as f:
    api_key_obj = json.load(f)
    api_key = api_key_obj["api_key"]
    res = requests.get(
        "https://api.openweathermap.org/data/2.5/weather",
        params={"q": "Waltham,MA,US", "appid": api_key},
    )
    print(res.text)
</code></pre>
<aside class="notes"><p> Weather APIs come and go, but right now
<a href="https://openweathermap.org/">OpenWeather</a> is providing decent data for free — even if
the default units are Kelvins.</p>
<p>Here's a simple call of their API; we load the API key from a JSON file, we
make a request, and then we print out the response text.</p>
<p>Let's work on recreating this in Rust.</p>
<div class="next-slide"><p>Next slide: Reading the API key from JSON.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust no-line-numbers left" data-line-numbers="1-15|4|5-6|7-13" data-noescape="">use <a href="https://docs.rs/serde_json">serde_json</a>::Value;

fn main() {
    let api_key_json = include_str!("../openweather_api.json");
    let api_key_obj: Value =
        serde_json::from_str(api_key_json).unwrap();
    let api_key = api_key_obj
        .as_object()
        .unwrap()
        .get("api_key")
        .unwrap()
        .as_str()
        .unwrap();
    println!("API key is {}", api_key);
}
</code></pre>
<aside class="notes"><p> Here's a start at a line-by-line conversion of that program.</p>
<ol>
<li>
<p>We're using <code>include_str!</code> here which actually reads a file as UTF-8 at
<em>compile time</em> — we'll work on opening files in a bit, but this works well
enough, end this is very much a "the perfect is the enemy of the good" talk.</p>
</li>
<li>
<p>Next, we use <a href="https://docs.rs/serde_json"><code>serde_json</code></a> to parse that string into a JSON value.</p>
</li>
<li>
<p>Then, we get the <code>api_key</code> key out of the object as a string. Each time
we assert something about the type of a value in this object, we need to
unwrap it, because we might <em>not</em> have a value of the type we want, so we
need to deal with that somehow.</p>
<p>Note that this isn't entirely unique to Rust, though — our
Python program would also crash if <code>api_key_obj</code> wasn't a JSON object, or if
it didn't have a key named <code>api_key</code>, or if the value to that key wasn't a
string. But Rust makes us be explicit about it.</p>
<p>That's not entirely a bad thing — it helps us figure out where errors
could happen — but it is awfully verbose and painful to write.</p>
<p>Fortunately, there's a better way.</p>
</li>
</ol>
<div class="next-slide"><p>Next slide: <code>Deserialize</code> derive.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust" data-noescape="">use <a href="https://docs.rs/serde">serde</a>::Deserialize;

#[derive(Debug, Clone, Deserialize)]
struct OpenWeatherConfig {
    api_key: String,
}
</code></pre>
<aside class="notes"><p> Here, we're declaring a struct, which is roughly a class, in the sense
of a blob of data with named fields and methods. Then, we <em>derive</em> some traits
for it. Traits are what Python programmers sometimes call protocols, or what
Java calls interfaces. Here, <code>Debug</code> lets us pretty-print the struct's data,
<code>Clone</code> lets us deeply copy it, and <a href="https://docs.rs/serde"><code>serde</code></a>'s <code>Deserialize</code> lets us
deserialize it from JSON — or, with other serde libraries, XML, YAML, TOML,
Protobufs, and more.</p>
<div class="next-slide"><p>Next slide: Using the <code>Deserialize</code> implementation with <a href="https://docs.rs/serde_json"><code>serde_json</code></a>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/serde">serde</a>::Deserialize;

fn main() {
    let config_json = include_str!("../openweather_api.json");
    let config: OpenWeatherConfig =
        serde_json::from_str(config_json).unwrap();
    println!("{:?}", config);
}
</code></pre>
<aside class="notes"><p> Here's what deserializing to a value looks like. Note that we don't need
to explicitly construct our <code>OpenWeatherConfig</code> object — that, along with
parsing the JSON, matching up keys to fields, and recursively constructing
other <code>Deserialize</code>able values, is handled by <a href="https://docs.rs/serde"><code>serde</code></a> and <a href="https://docs.rs/serde_json"><code>serde_json</code></a>.</p>
<div class="next-slide"><p>Next slide: Running this example.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ cat openweather_api.json
{
  "api_key": "1b13e6aa173ce14137a50095476e653c"
}

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/rustconf-code`
OpenWeatherConfig {
    api_key: "1b13e6aa173ce14137a50095476e653c"
}
</code></pre>
<aside class="notes"><p> Now when we run this, we get some nice pretty-printed debug output by default.</p>
<p>That's not my actual API key, by the way. Don't worry.</p>
<div class="next-slide"><p>Next slide: Adding the <a href="https://docs.rs/structopt"><code>structopt</code></a> crate.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/std">std</a>::path::PathBuf;

use <a href="https://docs.rs/structopt">structopt</a>::StructOpt;

/// A command-line interface to the openweathermap.org API.
#[derive(Debug, StructOpt)]
struct Opt {
    /// Config filename; a JSON file with an `api_key` field.
    #[structopt(short, long, parse(from_os_str))]
    config: PathBuf,
}

fn main() {
    let opt = Opt::from_args();
    // ...
}
</code></pre>
<aside class="notes"><p> The next change I want to make is adding <a href="https://docs.rs/structopt"><code>structopt</code></a>, which
derives a command-line interface from a struct definition. Instead of declaring
all our arguments as strings and pulling them out of an untyped hashmap, we
just declare them as struct fields — which means we get autocompletion for
our command-line options, along with bonuses like detecting that <code>Option</code>
fields aren't mandatory and <code>Vec</code> fields can have multiple values.</p>
<div class="next-slide"><p>Next slide: Generated help message.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ ./target/debug/rustconf-code --help
rustconf-code 0.1.0
A command-line interface to the openweathermap.org API

USAGE:
    rustconf-code --config &lt;config&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --config &lt;config&gt;    Config filename; a JSON file with
                             an `api_key` field
</code></pre>
<aside class="notes"><p> We get a lot of perks from <a href="https://docs.rs/structopt"><code>structopt</code></a>, including the great
generated help message.</p>
<div class="next-slide"><p>Next slide: Argument typo help.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ ./target/debug/rustconf-code --confgi my-custom-file.json
error: Found argument '--confgi' which wasn't expected, or isn't
       valid in this context
       Did you mean --config?

USAGE:
    rustconf-code --config &lt;config&gt;

For more information try --help
</code></pre>
<aside class="notes"><p> <a href="https://docs.rs/structopt"><code>structopt</code></a> even helps us with typos by default.</p>
<div class="next-slide"><p>Next slide: Adding <a href="https://docs.rs/eyre"><code>eyre</code></a>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left no-line-numbers" data-line-numbers="1-8|3,5" data-noescape="">fn main() -&gt; eyre::Result&lt;()&gt; {
    let opt = Opt::from_args();
    let config_json = File::open(&amp;opt.config)?;
    let config: OpenWeatherConfig =
        serde_json::from_reader(&amp;config_json)?;
    println!("Config: {:#?}", config);
    Ok(())
}
</code></pre>
<aside class="notes"><p> The next thing I want to do is add some error reporting, so we don't
have to unwrap everything and cause panics. <a href="https://docs.rs/eyre"><code>eyre</code></a> gives us the
beautifully-formatted error messages I showed off at the beginning of the talk,
and has a ton of functionality we won't explore here.</p>
<p>Now, we're handling this errors with the "try" operator, spelled <code>?</code>. That's a
pretty simple but important bit of syntax sugar.</p>
<div class="next-slide"><p>Next slide: Syntax sugar for <code>?</code>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left no-line-numbers" data-line-numbers="4-7,9-12" data-noescape="">fn main() -&gt; eyre::Result&lt;()&gt; {
    let opt = Opt::from_args();
    let config_json =
        match File::open(&amp;opt.config) {
            Ok(file) =&gt; file,
            Err(err) =&gt; return Err(err.into()),
        };
    let config: OpenWeatherConfig =
        match serde_json::from_reader(&amp;config_json) {
            Ok(config) =&gt; config,
            Err(err) =&gt; return Err(err.into()),
        };
    println!("Config: {:#?}", config);
    Ok(())
}
</code></pre>
<aside class="notes"><p> The <code>?</code>s are transformed into roughly these match statements; if we have
an <code>Ok</code> value, we take that value and use it. Otherwise, we return the <code>Err</code>
value from the whole function — we just bubble up the error to the caller.
It's a little bit like throwing an exception, but we don't quit an arbitrary
series of functions — we only go up one layer, and the type system doesn't
let us ignore it.</p>
<div class="next-slide"><p>Next slide: <code>WrapErr</code> and context.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust no-line-numbers left" data-line-numbers="1,6-11,14" data-noescape="">use <a href="https://docs.rs/eyre">eyre</a>::WrapErr;

fn main() -&gt; eyre::Result&lt;()&gt; {
    let opt = Opt::from_args();
    let config_json =
        File::open(&amp;opt.config).wrap_err_with(|| {
            format!(
                "Failed to open config file {:?}",
                opt.config
            )
        })?;
    let config: OpenWeatherConfig =
        serde_json::from_reader(&amp;config_json)
            .wrap_err("Failed to deserialize JSON")?;
    println!("Config: {:#?}", config);
    Ok(())
}
</code></pre>
<aside class="notes"><p> Using the <code>?</code> operator again, we're going to use the <code>wrap_err</code> methods
from <a href="https://docs.rs/eyre"><code>eyre</code></a>'s <code>WrapErr</code> trait to attach context to our errors. We just
write a bit about what we were doing that might have caused an error, and then
that string will get displayed if the error report is printed. It's a pretty
simple step — provided you do it from the start — and it makes debugging a
<em>lot</em> easier.</p>
<div class="next-slide"><p>Next slide: Error report examples.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ ./target/debug/rustconf-code --config nonexistent-file.json
Error: Failed to open config file "nonexistent-file.json"

Caused by:
    No such file or directory (os error 2)

$ ./target/debug/rustconf-code --config invalid-file.json
Error: Failed to deserialize JSON

Caused by:
    trailing comma at line 3 column 1
</code></pre>
<aside class="notes"><p> Here we can try to use a nonexistent file or an invalid file for our
config file and we can see the error messages we get.</p>
<p>These are pretty simple, but they're especially useful when we have a bunch of
layers of error context to figure out what we did wrong — and unlike
exceptions in a lot of languages, we don't just get an enormous unreadable
stack trace by default.</p>
<div class="next-slide"><p>Next slide: Using <code>reqwest</code> for HTTP requests.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">use <a href="https://docs.rs/reqwest">reqwest</a>::blocking::{Client, Response};

fn get_weather(
    api_key: &amp;str,
) -&gt; Result&lt;Response, reqwest::Error&gt; {
    let client = Client::new();
    client
        .get("https://api.openweathermap.org/data/2.5/weather")
        .query(&amp;[("q", "Waltham,MA,US"), ("appid", api_key)])
        .send()
}
</code></pre>
<aside class="notes"><p> Now we're going to use the <a href="https://docs.rs/reqwest"><code>reqwest</code></a> library to make a simple call
to the <a href="https://openweathermap.org/">openweathermap.org</a> API.</p>
<div class="next-slide"><p>Next slide: Making the call and printing the result.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">println!("Response: {:#?}", get_weather(&amp;config.api_key)?);
</code></pre>
<pre><code class="language-shell-session left">$ cargo run
Response: Response {
    url: "https://api.openweathermap.org/data/2.5/weather?q=...",
    status: 200,
    headers: {
        "server": "openresty",
        "date": "Sun, 19 Jul 2020 19:30:04 GMT",
        "content-type": "application/json; charset=utf-8",
        "content-length": "465",
        "connection": "keep-alive",
        "x-cache-key": "/data/2.5/weather?q=waltham%2cma%2cus",
        "access-control-allow-origin": "*",
        "access-control-allow-credentials": "true",
        "access-control-allow-methods": "GET, POST",
    },
}
</code></pre>
<aside class="notes"><p> We can see when we pretty-print the <code>Response</code> object, we get all the
fields we might expect — headers, a status code, and so on.</p>
<div class="next-slide"><p>Next slide: Extracting the response text.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">let res = get_weather(&amp;config.api_key)?;
let bytes = res.bytes()?;
println!("{}", String::from_utf8_lossy(&amp;*bytes));
</code></pre>
<pre><code class="language-json left">{"coord":{"lon":-71.24,"lat":42.38},"weather":[{"id":802,
"main":"Clouds","description":"scattered clouds","icon":
"03d"}],"base":"stations","main":{"temp":308.71,"feels_like":
307.42,"temp_min":307.59,"temp_max":309.82,"pressure":1010,
"humidity":37},"visibility":10000,"wind":{"speed":6.2, ...
</code></pre>
<aside class="notes"><p> We can also print the response text, which is this big minified JSON
blob. We're going to deserialize that, too, but first let's clean up our
interface to the <a href="https://openweathermap.org/">openweathermap.org</a> API.</p>
<div class="next-slide"><p>Next slide: Including a <code>Client</code> in the deserialized config.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust" data-noescape="">use <a href="https://docs.rs/reqwest">reqwest</a>::blocking::Client;
use <a href="https://docs.rs/serde">serde</a>::Deserialize;

#[derive(Deserialize, Debug, Clone)]
struct OpenWeather {
    api_key: String,

    lat: f64,
    lon: f64,

    #[serde(skip)]
    client: Client,
}
</code></pre>
<aside class="notes"><p> While we're at it, let's unify our config file with our API client --
instead of passing an API key into every function call, we can keep it in the
same struct that holds the <a href="https://docs.rs/reqwest"><code>reqwest</code></a> client. And because the <code>Client</code> has a
default value, we can tell serde to use that instead of expecting it in our
config file.</p>
<div class="next-slide"><p>Next slide: Deserializing <code>OpenWeather</code> from a reader.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">fn main() -&gt; eyre::Result&lt;()&gt; {
    // ...
    let config: OpenWeather = serde_json::from_reader(
        &amp;config_json,
    )?;
    // ...
}
</code></pre>
<aside class="notes"><p> Now, we can just read our config object from the same JSON file we were
using before, without even a constructor method.</p>
<div class="next-slide"><p>Next slide: <code>impl OpenWeather</code>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust no-line-numbers left" data-line-numbers="1-10|3|2,6" data-noescape="">impl OpenWeather {
    fn get&lt;Response: DeserializeOwned&gt;(
        &amp;self,
        endpoint: &amp;str,
        params: &amp;[(&amp;str, &amp;str)],
    ) -&gt; eyre::Result&lt;Response&gt; {
      // I have discovered a truly marvelous implementation
      // of this method, which this slide is too narrow
      // to contain.
    }
}
</code></pre>
<aside class="notes"><p> Now, to make our API a bit cleaner, let's start implementing methods.
This gives us something that looks a lot like the classes we're familiar with
— Rust doesn't have inheritance or subtyping, although generic functions and
traits get us pretty close.</p>
<p>An <code>impl</code> block lets us put methods on types.</p>
<ol>
<li>Like Python, Rust doesn't have an implicit <code>this</code> object you can reference
— you need to write it explicitly.</li>
<li>We also have angle brackets after the function name to indicate a generic
function. Here, we have one generic parameter named <code>Response</code> and the colon
indicates a <em>trait bound,</em> which means that <code>Response</code> has to be a type with
an implementation of <code>DeserializeOwned</code> — which is exactly what
<code>#[derive(Deserialize)]</code> gives us. Essentially, we've copied a type
parameter from <a href="https://docs.rs/serde_json"><code>serde_json</code></a><code>::from_reader</code> so that we can deserialize
any type we define.</li>
</ol>
<div class="next-slide"><p>Next slide: API response struct definitions.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust" data-noescape="">#[derive(Deserialize, Debug, Clone)]
pub struct OneCall {
    pub hourly: Vec&lt;Hourly&gt;,
    pub daily: Vec&lt;Daily&gt;,
}

#[derive(Deserialize, Debug, Clone)]
pub struct Hourly {
    pub dt: UnixUTC,
    pub temp: f64,
    pub feels_like: f64,
    pub humidity: f64,
    pub clouds: f64,
    pub rain: Option&lt;Rain&gt;,
    pub snow: Option&lt;Snow&gt;,
}
</code></pre>
<aside class="notes"><p> We can define structs for the API responses --- these are pretty much
copied from the <a href="https://openweathermap.org/">openweathermap.org</a> API docs.</p>
<div class="next-slide"><p>Next slide: <code>OpenWeather::onecall</code> method and use.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust no-line-numbers left" data-line-numbers="1-9|11-17" data-noescape="">impl OpenWeather {
    fn onecall(&amp;self) -&gt; eyre::Result&lt;OneCall&gt; {
        self.get(
            "onecall",
            &amp;[ ("exclude", "currently,minutely"),
                ("units", "imperial"), ],
        )
    }
}

fn main() -&gt; eyre::Result&lt;()&gt; {
    // ...
    let onecall: OneCall = config
        .onecall()
        .wrap_err("Failed to deserialize hourly weather data")?;
}
</code></pre>
<aside class="notes"><p></p>
<ol>
<li>
<p>Then we can define a helper method to make that request directly. Note that
we don't need to annotate that <code>self.get</code> should be used with the generic
type parameter <code>Response</code> as <code>OneCall</code> — the Rust compiler is smart enough
to figure out that because we're returning the result of <code>self.get</code> from
<code>OpenWeather::onecall</code>, <code>Response</code> can <em>only</em> possibly be <code>OneCall</code>.</p>
</li>
<li>
<p>And then, of course, we can use the new method in our <code>main</code> to get the
forecast data as a richly-typed struct.</p>
</li>
</ol>
<div class="next-slide"><p>Next slide: <code>TempDifference</code></p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code>#[derive(Debug, PartialEq)]
enum TempDifference {
    MuchColder,
    Colder,
    Same,
    Warmer,
    MuchWarmer,
}
</code></pre>
<aside class="notes"><p> One thing I want from my forecast is to tell me if today is going to be
warmer or colder than yesterday. So I'll create a <code>TempDifference</code> enum, and
then a helper method to get the appropriate <code>TempDifference</code> for two floats.</p>
<div class="next-slide"><p>Next slide: <code>Stats</code>.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">let yesterday =
    Stats::from(historical.iter().map(|h| h.feels_like));
let today = Stats::from(
    onecall.hourly.iter().map(|h| h.feels_like).take(24),
);

let diff = TempDifference::from(yesterday.avg, today.avg);
</code></pre>
<aside class="notes"><p> Then, I'm going to gather the minimum, maximum, and average temperature
from yesterday and the forecast for today into these <code>Stats</code> structs I've
created.</p>
<div class="next-slide"><p>Next slide: Printing the result.</p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-rust left" data-noescape="">let today_is_warm = 60.0 &lt;= today.avg &amp;&amp; today.avg &lt;= 80.0;
print!("Good morning! Today will be about {:.2}°F ", today.avg);
println!(
    "({min} - {max}°F); that's {diff} {than} yesterday{end}",
    min = today.min,
    max = today.max,
    diff = diff,
    than = match diff {
        TempDifference::Same =&gt; "as",
        _ =&gt; "than",
    },
    end = if today_is_warm { ":)" } else { "." },
);
</code></pre>
<aside class="notes"><p> And then we can print all this information out, and we're done!</p>
<div class="next-slide"><p>Next slide: Running the final program.</p></div>
<!-- have a receipt printer video...? -->
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section><div class="slide-wrapper">
<pre><code class="language-shell-session left">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s

$ ./target/debug/rustconf-code
Good morning! Today will be about 85.16°F (76.42 - 94.96°F);
that's about the same as yesterday.
</code></pre>
</div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section class="title-card" data-state="purple"><div class="slide-wrapper">
<h2>This is only a taste</h2>
<aside class="notes"><p> Everything I just talked about is just a tiny portion of what you can do
with Rust — and what Rust can do for you. There's so many features and tools
I wanted to talk about that I didn't have time for — adding methods to
foreign types, type-safe numbers and unit conversions.</p>
<div class="next-slide"><p>Next slide: <strong>None.</strong></p></div>
</aside></div><div class="slide-footer">
<div class="slide-footer-left">Rebecca Turner (<a href="https://pronoun.is/she/her/">she/her</a>)</div>
<div class="slide-footer-right">
<i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo">becca.ooo</a>
</div>
</div></section>
<section data-state="ruby"><div class="slide-wrapper">
<h1>Rust <div class="small">for</div> Non-Systems Programmers</h1>
<p><span class="author">Rebecca Turner</span></p>
<p><i class="fa-twitter fab"></i> <a href="https://twitter.com/16kbps">@16kbps</a> / <a href="https://becca.ooo/">becca.ooo</a></p>
<aside class="notes"><p> Thanks so much for listening, and I hope you do some amazing things with
Rust!</p>
</aside></div></section>
</div>
</div>
<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/highlight/rust.js"></script>
<script src="plugin/highlight/shell.js"></script>
<script>
        Reveal.initialize({
            width: 960,
            height: 540,
            hash: true,
            controls: false,
            progress: false,
            showNotes: true,
            transition: 'none',
            /* vertical- */ center: false,
            markdown: {
                smartypants: true,
            },
            plugins: [RevealMarkdown, HighlightRustCompiler, HighlightShellSession, RevealHighlight, RevealNotes]
        });

        // new EventSource("tide-reload").addEventListener("reload", event => {
        //     console.log(event);
        // });
    </script>
</body>
</html>

